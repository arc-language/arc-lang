package amd

import (
	"bytes"
	"fmt"

	"github.com/arc-language/arc-lang/builder/ir"
	"github.com/arc-language/arc-lang/builder/types"
)

// Generator handles the emission of AMD GCN Assembly (ISA)
// Target: HSA Code Object v3 (gfx900+)
type Generator struct {
	buf      *bytes.Buffer
	regMap   map[ir.Value]string
	blockMap map[*ir.BasicBlock]string
	nextReg  int
}

// Generate compiles an IR module into a GCN assembly string.
// This text corresponds to what hipcc or an assembler would compile to a .hsaco
func Generate(m *ir.Module) (string, error) {
	g := &Generator{
		buf:      new(bytes.Buffer),
		regMap:   make(map[ir.Value]string),
		blockMap: make(map[*ir.BasicBlock]string),
	}

	g.emitHeader()

	for _, fn := range m.Functions {
		if fn.CallConv != ir.CC_ROCM {
			continue
		}
		if err := g.emitFunction(fn); err != nil {
			return "", err
		}
	}

	return g.buf.String(), nil
}

func (g *Generator) emitHeader() {
	g.printf("// Generated by Arc Compiler for AMD ROCm (GCN)\n")
	g.printf(".hsa_code_object_version 2,1\n")
	g.printf(".hsa_code_object_isa 9,0,0, \"AMD\", \"AMDGPU\"\n\n")
}

func (g *Generator) emitFunction(fn *ir.Function) error {
	g.regMap = make(map[ir.Value]string)
	g.blockMap = make(map[*ir.BasicBlock]string)
	g.nextReg = 0

	// Kernel directive
	g.printf(".text\n")
	g.printf(".globl %s\n", fn.Name())
	g.printf(".amdgpu_hsa_kernel %s\n", fn.Name())
	g.printf("%s:\n", fn.Name())
	
	// Setup Kernel Header (simplified)
	g.printf("\t.amd_kernel_code_t\n")
	g.printf("\t\tenable_sgpr_kernarg_segment_ptr = 1\n")
	g.printf("\t\tis_ptr64 = 1\n")
	g.printf("\t\tcompute_pgm_rsrc1_vgprs = 64\n") // Reserve 64 VGPRs safe limit
	g.printf("\t\tcompute_pgm_rsrc1_sgprs = 16\n")
	g.printf("\t.end_amd_kernel_code_t\n\n")

	// Map Blocks
	for i, block := range fn.Blocks {
		g.blockMap[block] = fmt.Sprintf(".L%s_%d", fn.Name(), i)
	}

	// Argument Loading
	// In GCN, Kernargs are passed via a pointer in s[0:1].
	// We must load them manually.
	g.printf("; Load Arguments\n")
	offset := 0
	g.printf("\ts_load_dwordx2 s[0:1], s[0:1], 0x0 ; Load kernarg ptr\n")
	g.printf("\ts_waitcnt lgkmcnt(0)\n")

	for i, arg := range fn.Arguments {
		// Map argument to a VGPR
		reg := g.allocVGPR(arg)
		
		// Load from kernarg segment (scalar load then move to vector for usage)
		// Assuming 64-bit pointers/values for simplicity in this mock
		g.printf("\ts_load_dwordx2 s[2:3], s[0:1], 0x%x ; Load arg %d\n", offset, i)
		g.printf("\ts_waitcnt lgkmcnt(0)\n")
		g.printf("\tv_mov_b32_e32 %s, s2\n", reg)
		// If 64-bit, we need a second VGPR, simplified here to just lower 32
		
		offset += 8 // All args 64-bit aligned for simplicity
	}

	// Register Alloc for Instructions
	for _, block := range fn.Blocks {
		for _, inst := range block.Instructions {
			if inst.Type() != nil && inst.Type() != types.Void && inst.Opcode() != ir.OpAlloca {
				g.allocVGPR(inst)
			}
		}
	}

	// Emit Blocks
	for _, block := range fn.Blocks {
		g.printf("\n%s:\n", g.blockMap[block])
		for _, inst := range block.Instructions {
			if err := g.emitInstruction(inst); err != nil {
				return err
			}
		}
	}

	g.printf("\ts_endpgm\n\n")
	return nil
}

func (g *Generator) allocVGPR(v ir.Value) string {
	name := fmt.Sprintf("v%d", g.nextReg)
	g.nextReg++
	g.regMap[v] = name
	return name
}

func (g *Generator) emitInstruction(inst ir.Instruction) error {
	switch inst.Opcode() {
	case ir.OpAdd:
		g.emitBinary("v_add_u32", inst)
	case ir.OpSub:
		g.emitBinary("v_sub_u32", inst)
	case ir.OpMul:
		g.emitBinary("v_mul_lo_u32", inst) // 32-bit mult
	
	case ir.OpFAdd:
		g.emitBinary("v_add_f32", inst)
	case ir.OpFSub:
		g.emitBinary("v_sub_f32", inst)
	case ir.OpFMul:
		g.emitBinary("v_mul_f32", inst)
	case ir.OpFDiv:
		// approximate reciprocal? GCN does not have single div instruction
		// using macro or pseudo for now
		dst := g.regMap[inst]
		src1 := g.getOp(inst.Operands()[0])
		src2 := g.getOp(inst.Operands()[1])
		g.printf("\tv_div_scale_f32 %s, ... %s, %s ; Pseudo div\n", dst, src1, src2)

	case ir.OpLoad:
		dst := g.regMap[inst]
		ptr := g.getOp(inst.Operands()[0])
		// Flat load (can access global or shared)
		g.printf("\tflat_load_dword %s, %s\n", dst, ptr)
		g.printf("\ts_waitcnt vmcnt(0) lgkmcnt(0)\n")

	case ir.OpStore:
		val := g.getOp(inst.Operands()[0])
		ptr := g.getOp(inst.Operands()[1])
		g.printf("\tflat_store_dword %s, %s\n", ptr, val)

	case ir.OpAlloca:
		// GCN stack is handled via scratch resources, complex to implement manually.
		// We'll stub it using a mock register offset.
		dst := fmt.Sprintf("v%d", g.nextReg) 
		g.nextReg++
		g.regMap[inst] = dst
		g.printf("\t; alloca %s (stub)\n", inst.Name())

	case ir.OpICmp:
		// v_cmp_eq_u32 vcc, s0, s1
		// writes to VCC (Vector Condition Code)
		// We need to move VCC to the destination VGPR
		dst := g.regMap[inst]
		src1 := g.getOp(inst.Operands()[0])
		src2 := g.getOp(inst.Operands()[1])
		
		cmp := "eq" // map predicate...
		g.printf("\tv_cmp_%s_u32 vcc, %s, %s\n", cmp, src1, src2)
		g.printf("\tv_cndmask_b32_e64 %s, 0, 1, vcc\n", dst)

	case ir.OpBr:
		target := g.blockMap[inst.(*ir.BrInst).Target]
		g.printf("\ts_branch %s\n", target)

	case ir.OpCondBr:
		cbr := inst.(*ir.CondBrInst)
		cond := g.getOp(cbr.Condition)
		tBlock := g.blockMap[cbr.TrueBlock]
		fBlock := g.blockMap[cbr.FalseBlock]
		
		// Compare condition reg to 0
		g.printf("\tv_cmp_ne_u32 vcc, 0, %s\n", cond)
		g.printf("\ts_cbranch_vccnz %s\n", tBlock)
		g.printf("\ts_branch %s\n", fBlock)

	case ir.OpRet:
		g.printf("\ts_endpgm\n")

	default:
		g.printf("\t; Unimplemented Op: %s\n", inst.Opcode())
	}
	return nil
}

func (g *Generator) emitBinary(mnemonic string, inst ir.Instruction) {
	dst := g.regMap[inst]
	src1 := g.getOp(inst.Operands()[0])
	src2 := g.getOp(inst.Operands()[1])
	g.printf("\t%s %s, %s, %s\n", mnemonic, dst, src1, src2)
}

func (g *Generator) getOp(v ir.Value) string {
	if c, ok := v.(*ir.ConstantInt); ok {
		return fmt.Sprintf("%d", c.Value)
	}
	if c, ok := v.(*ir.ConstantFloat); ok {
		return fmt.Sprintf("%f", c.Value)
	}
	if reg, ok := g.regMap[v]; ok {
		return reg
	}
	return "v0" // fallback
}

func (g *Generator) printf(format string, args ...interface{}) {
	fmt.Fprintf(g.buf, format, args...)
}